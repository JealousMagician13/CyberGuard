"use server"

export async function scanForMalware(urlOrFileId: string, isFile: boolean) {
  try {
    const apiKey = "3d4d4cecab9b20870c516fe0b8082752f9bba80cb481811181677552d770f861"
    if (!apiKey) {
      return { success: false, error: "API key not configured" }
    }

    let analysisId: string | null = null
    let resourceId: string | null = null

    if (isFile) {
      // File ID was provided (from the upload endpoint)
      resourceId = urlOrFileId

      // Get file analysis
      const analysisResponse = await fetch(`https://www.virustotal.com/api/v3/files/${resourceId}`, {
        headers: {
          "x-apikey": apiKey,
        },
      })

      if (!analysisResponse.ok) {
        const errorData = await analysisResponse.json()
        return { success: false, error: errorData.error?.message || "Failed to get file analysis" }
      }

      const analysisData = await analysisResponse.json()
      return processMalwareResult(analysisData, true)
    } else {
      // URL was provided
      // Validate URL format
      try {
        new URL(urlOrFileId)
      } catch (e) {
        return { success: false, error: "Invalid URL format" }
      }

      // Get URL ID (base64 encoded)
      const urlId = Buffer.from(urlOrFileId)
        .toString("base64")
        .replace(/\+/g, "-")
        .replace(/\//g, "_")
        .replace(/=+$/, "")
      resourceId = urlId

      // Check if URL exists in VirusTotal
      const checkResponse = await fetch(`https://www.virustotal.com/api/v3/urls/${urlId}`, {
        headers: {
          "x-apikey": apiKey,
        },
      })

      if (checkResponse.status === 404) {
        // URL not analyzed yet, submit for analysis
        const formData = new URLSearchParams()
        formData.append("url", urlOrFileId)

        const submitResponse = await fetch("https://www.virustotal.com/api/v3/urls", {
          method: "POST",
          headers: {
            "x-apikey": apiKey,
            "Content-Type": "application/x-www-form-urlencoded",
          },
          body: formData,
        })

        if (!submitResponse.ok) {
          const errorData = await submitResponse.json()
          return { success: false, error: errorData.error?.message || "Failed to submit URL for analysis" }
        }

        const submitData = await submitResponse.json()
        analysisId = submitData.data.id

        // Wait for analysis to complete (poll)
        let analysisComplete = false
        let analysisResult = null
        let attempts = 0

        while (!analysisComplete && attempts < 10) {
          attempts++

          // Wait 2 seconds between polls
          await new Promise((resolve) => setTimeout(resolve, 2000))

          const analysisResponse = await fetch(`https://www.virustotal.com/api/v3/analyses/${analysisId}`, {
            headers: {
              "x-apikey": apiKey,
            },
          })

          if (!analysisResponse.ok) {
            continue
          }

          const analysisData = await analysisResponse.json()
          if (analysisData.data.attributes.status === "completed") {
            analysisComplete = true

            // Get the full URL report
            const urlResponse = await fetch(`https://www.virustotal.com/api/v3/urls/${urlId}`, {
              headers: {
                "x-apikey": apiKey,
              },
            })

            if (urlResponse.ok) {
              analysisResult = await urlResponse.json()
            }
          }
        }

        if (!analysisResult) {
          return { success: false, error: "Analysis timed out or failed" }
        }

        return processMalwareResult(analysisResult, false)
      } else if (checkResponse.ok) {
        // URL already analyzed
        const data = await checkResponse.json()
        return processMalwareResult(data, false)
      } else {
        const errorData = await checkResponse.json()
        return { success: false, error: errorData.error?.message || "Failed to check URL" }
      }
    }
  } catch (error) {
    console.error("Error scanning for malware:", error)
    return {
      success: false,
      error: error instanceof Error ? error.message : "An unknown error occurred",
    }
  }
}

function processMalwareResult(data: any, isFile: boolean) {
  try {
    const attributes = data.data.attributes
    const stats = attributes.last_analysis_stats

    // Calculate risk score (0-100)
    const totalEngines = stats.harmless + stats.malicious + stats.suspicious + stats.undetected
    const riskScore = Math.round(((stats.malicious + stats.suspicious) / totalEngines) * 100)

    // Determine risk level
    let riskLevel = "clean"
    if (riskScore >= 5 && riskScore < 20) {
      riskLevel = "suspicious"
    } else if (riskScore >= 20) {
      riskLevel = "malicious"
    }

    // Get malware categories and names
    const results = attributes.last_analysis_results
    const detections: { engine: string; category: string; result: string }[] = []

    Object.entries(results).forEach(([engine, result]: [string, any]) => {
      if (result.category === "malicious" || result.category === "suspicious") {
        detections.push({
          engine,
          category: result.category,
          result: result.result || "Unknown",
        })
      }
    })

    // Sort detections by engine name
    detections.sort((a, b) => a.engine.localeCompare(b.engine))

    const response: any = {
      success: true,
      analysis: {
        riskScore,
        riskLevel,
        detections,
        stats: {
          malicious: stats.malicious,
          suspicious: stats.suspicious,
          harmless: stats.harmless,
          undetected: stats.undetected,
        },
        lastAnalysisDate: new Date(attributes.last_analysis_date * 1000).toISOString(),
      },
    }

    if (isFile) {
      response.analysis.file = {
        name: attributes.meaningful_name || "Unknown",
        type: attributes.type_description || "Unknown",
        size: attributes.size || 0,
        md5: attributes.md5 || "",
        sha1: attributes.sha1 || "",
        sha256: attributes.sha256 || "",
      }
    } else {
      response.analysis.url = attributes.url || ""
    }

    return response
  } catch (error) {
    console.error("Error processing malware result:", error)
    return {
      success: false,
      error: "Failed to process analysis results",
    }
  }
}

export async function getUploadUrl() {
  try {
    const apiKey = process.env.VIRUSTOTAL_API_KEY
    if (!apiKey) {
      return { success: false, error: "API key not configured" }
    }

    const response = await fetch("https://www.virustotal.com/api/v3/files/upload_url", {
      headers: {
        "x-apikey": apiKey,
      },
    })

    if (!response.ok) {
      const errorData = await response.json()
      return { success: false, error: errorData.error?.message || "Failed to get upload URL" }
    }

    const data = await response.json()
    return { success: true, uploadUrl: data.data }
  } catch (error) {
    console.error("Error getting upload URL:", error)
    return {
      success: false,
      error: error instanceof Error ? error.message : "An unknown error occurred",
    }
  }
}
